实体类编写规则：
    1.属性私有化

    2.私有属性使用公开的set get方法操作

    3.要求有一个作为唯一值得属性(一般为id)

    4.属性不建议使用基本数据类型，而应是对应包装类
        int-> Integer
        char->Character
        其他都是首字母大写，如：double->Double

        为什么不建议基本数据类型?
            基本数据类型在表示学生是0分还是没来参加考试时，不好表示，但是包装类可以：0表示0分，null表示没来。


实体类对象状态：
    瞬时态：对象里面没有id值，对象与session没有关联
        User u = new User();
        u.setUsername("jack");
        u.setPassword("111");

    持久态：对象有id，有与session关联
        User user = session.get(User.class, 1);

    托管态：有id，无关联
        User user = new User();
        user.setUid(3);

Hibernate的一级缓存：
    为什么使用缓存？
        1.数据库本身是文件系统，使用流方式操作文件效率低
        2.把数据缓存到内存，直接读取内存的数据效率高

Hibernate缓存特点：
    一级缓存
        1.默认打开
        2.一级缓存使用范围，是session范围，从session创建到session关闭
        3.一级缓存中，数据必须是持久态数据

    二级缓存
        1.已被redis淘汰
        2.默认不打开
        3.范围是sessionFactory范围


验证一级缓存的存在：
    1.根据uid = 1查询，返回对象
    1.再次根据uid = 1查询，返回对象

一级缓存特点：
    1.持久态自动更新数据库(磁盘)
        a):
            User user = session.get(User.class, 7);//1line
            user.setUsername("hanser");//2line
        b)执行过程：
            1line:
                1.把返回的user持久态对象放到一级缓存中 --> 2.把user对象放到一级缓存对应的快照区中
            2line:
                3.修改user对象的username的值set为hanser,同时修改1中一级缓存区内容为hanser(不会修改快照区)

            最后提交事务：
                比较：
                    比较一级缓冲区内容和对应的快照区内容是否一样，如果不一样，把一级缓存区内容更新到数据库(磁盘),如果一样，则不会更新到数据库


事务
    不考虑隔离性产生的问题
        1.脏读
        2.不可重复读
        3.虚读

    设置事务隔离级别
        1.mysql默认隔离级别 repeatable read

     代码规范：
     try {
        开启事务
        提交事务
     } catch() {
        回滚事务
     } finally {
        关闭
     }

Hibernate绑定session:
1.session类似于threadLocal和jdbc的connection

2.帮实现与本地线程绑定session

3.获取与本地线程绑定的session
    1.在hibernate核心配置文件中配置
        <property name="hibernate.current_session_context_class">thread</property>

    2.调用sessionFactory里面的方法得到
        sessionFactory.getCurrentSession();

     3.注意：
        获取与本地线程绑定的session的时候，手动关闭session会报错，因为线程会自动帮我们关闭



